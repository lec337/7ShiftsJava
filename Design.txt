Leon Cadotte, 7Shifts exercise
Part 1:
Generally we want to split up parsing string input and operating on this input, this will make the StringCalculator
more modular and will allow additional methods like subtraction, multiplication, etc to be easily supported.
So we want a separate method for converting input strings to integers, and another method for actually adding these integers.
Methods:
These methods could be static as the StringCalculator class has no data to store, however if we want to add support
for running totals, or store values temporarily as a calculator might, we would require instance methods instead.
For ease of testing, we use static methods, these could be changed rather easily to instance methods with slight modification
to testing.

inputToInt(String input):
converts input to an array of integers. Should maintain the order of the numbers in the string.
For example if "1,2,3" is input, we should return [1,2,3], this is useful for mathematical operations where the order
of operands matters, like subtraction or division.
This method will use a simple call to split(",") to separate the input string into an array of strings, these strings
can then be converted to integers. Additionally we should make sure the string input isn't empty, and that each split
string can be converted to an integer.

Add(String numbers):
Add will first check that 'numbers' isn't the empty string, if it is, return 0. Then we can use inputToInt to convert
'numbers' to an array of integers, we can then easily add these numbers

Part 2:
Here we just have to ignore newlines in inputToInt(), we can do this by replacing all newlines with empty strings.
We now have the potential error case where the user enters in an input containing all newlines, if this is the case,
we see that the empty string cannot be converted to an int and throw an exception, we give some message like:
"Cannot convert string number:  to an integer", this is because the number in question is the empty string, this is a
fair exception to throw as the user hasn't entered in any numbers and so we cannot convert their nothing into an integer.
In the Add() method, if the user enters in a string containing only newlines, we don't return 0, and instead throw an
exception, this is because the string the user entered wasn't empty, even though the newlines are ignored.


Part 3:
To account for this custom delimiter, in inputToInt(), before removing newlines, we need to extract the user's delimiter.
This can be done via regular expression, using the pattern "^//.+\n", we ensure that we only get matches from the
beginning of the string, we match "//" followed by any characters, ie the delimiter, then the newline, later we must remove
the starting // and ending newline to get the raw delimiter, this can be done via replacing these with empty strings.
we must be careful and replace the pattern "^//" and "\n$" to ensure that we don't remove part of the delimiter, if it
contains "\n" or "//", these patterns will only match the // at the start of the string and \n at the end of the string.
After splitting our input string by the delimiter, we can then remove newlines, we can only remove newlines here in case
the user's delimiter contains newlines or is the newline itself.
We impose the restriction that a user's delimiter cannot be the newline, as there is no way to tell between a delimiter
newline, newline after delimiter and other newlines that will be ignored, for example:
"//\n\n\n\n" do we consider "\n" to be a delimiter and ignore the last two \n's, or do we consider 3 \n's to be a delimiter
and the last newline to end the delimiter, since the behavior in this case isn't explicit, we don't allow the newline to
be a delimiter. We run into a similar case with using numbers as a delimiter, for example:
"//9\n,99999", is this "99999" supposed to evaluate to 9+9+9, or 999+9 or 99999, it is ambiguous, so we don't allow this
case.
Through testing additionally we find that characters with special meaning under regex "*", "+", "?" etc will be interpreted
with their regex meaning when we try to use these characters to .split(), if these characters are involved in our delimiter.
Since we want to split by these characters themselves, not by their special meaning, we want to escape each of these
characters. To do so, we can simply replace every non-word character (digit, letter) with its escaped version, for example
replace "+" with "\+" in our delimiter.
Add() is unchanged.

Part 4:
To support rejecting negative numbers, when we convert a string number to an integer, we can simply check if the resulting
int is negative, if so throw an exception in inputToInt, here we only list the first negative number we come across, we
don't list all potential negative numbers in the input. We can use a similar idea in Add() to ignore numbers larger than
1000, if an int in the array input to Add() is greater than 1000, we can simply not add it into our running sum of all
array numbers.